// this file is generated by servgen util based on a template at 2021-06-15 16:34:00 +0300 MSK
package storage

import (
	"context"
	"encoding/json"
	"time"

	"git.jetbrains.space/orbi/fcsd/auth/internal/domain"
	"git.jetbrains.space/orbi/fcsd/auth/internal/errors"
	"git.jetbrains.space/orbi/fcsd/auth/internal/logger"
	kitDb "git.jetbrains.space/orbi/fcsd/kit/db"
	"git.jetbrains.space/orbi/fcsd/kit/log"
	"github.com/go-redis/redis"
)

const (
	CacheKeyUserId    = "user.id:"
	CacheKeyUserEmail = "user.email:"
	CacheKeyUserToken = "user.token:"
	IndexUser         = "users"
)

type userStorageImpl struct {
	container *container
}

// sample is DB model
type user struct {
	kitDb.BaseDto
	Id           string    `gorm:"column:id"`
	Name         string    `gorm:"column:name"`
	Surname      string    `gorm:"column:surname"`
	Avatar       string    `gorm:"column:avatar"`
	FirebaseUUID string    `gorm:"column:firebase_uuid"`
	KundelikId   string    `gorm:"column:kundelik_id"`
	Email        string    `gorm:"column:email"`
	Password     string    `gorm:"column:password"`
	CountryCode  string    `gorm:"column:country_code"`
}

func newUserStorage(c *container) *userStorageImpl {
	return &userStorageImpl{
		container: c,
	}
}

func (a *userStorageImpl) l() log.CLogger {
	return logger.L().Cmp("user-storage")
}

func (a *userStorageImpl) setUserCacheAsync(ctx context.Context, dto user, keyId string) {

	go func() {

		l := a.l().Mth("set-cache").C(ctx).Dbg()

		j, err := json.Marshal(dto)
		if err != nil {
			l.E(err).St().Err()
		}
		dtoStr := string(j)

		// set cache for id key
		if err := a.container.Cache.Instance.Set(keyId, dtoStr, time.Hour).Err(); err != nil {
			l.E(errors.ErrUserStorageSetCache(err, ctx, dto.Id)).St().Err()
		}
	}()
}

func (a *userStorageImpl) CreateUser(ctx context.Context, user *domain.User) error {
	a.l().C(ctx).Mth("CreateUser")
	// save to DB
	if err := a.container.Db.Instance.Create(a.toUserDto(user)).Error; err != nil {
		return errors.ErrUserStorageCreate(err, ctx)
	}

	return nil
}

func (a *userStorageImpl) GetUser(ctx context.Context, id string) (*domain.User, error) {
	l := a.l().Mth("GetUser").C(ctx).F(log.FF{"id": id}).Dbg()

	key := CacheKeyUserId + id
	if j, err := a.container.Cache.Instance.Get(key).Result(); err == nil {
		// found in cache
		l.Dbg("found in cache")
		dto := &user{}
		if err := json.Unmarshal([]byte(j), &dto); err != nil {
			return nil, errors.ErrUserStorageGetCache(err, ctx, id)
		}
		return a.toUserDomain(dto), nil
	} else {
		if err == redis.Nil {
			// not found in cache
			dto := &user{Id: id}
			if res := a.container.Db.Instance.Limit(1).Where("deleted_at is null").Find(&dto); res.Error == nil {
				l.DbgF("db: found %d", res.RowsAffected)
				if res.RowsAffected == 0 {
					return nil, nil
				} else {
					// set cache async
					a.setUserCacheAsync(ctx, *dto, key)
					return a.toUserDomain(dto), nil
				}
			} else {
				return nil, errors.ErrUserStorageGetDb(res.Error, ctx, id)
			}

		} else {
			return nil, errors.ErrUserStorageGetCache(err, ctx, id)
		}
	}
}

func (a *userStorageImpl) UpdateUser(ctx context.Context, user *domain.User) error {
	a.l().Mth("UpdateUser").C(ctx).Dbg()

	// update DB
	if err := a.container.Db.Instance.Save(a.toUserDto(user)).Error; err != nil {
		return errors.ErrUserStorageUpdate(err, ctx, user.Id)
	}

	// clear cache
	keys := []string{CacheKeyUserId + user.Id,
		CacheKeyUserEmail + user.Email,
		CacheKeyUserToken + user.FirebaseUUID,
		CacheKeyUserToken + user.KundelikId}
	a.container.Cache.Instance.Del(keys...)

	return nil
}

func (a *userStorageImpl) DeleteUser(ctx context.Context, id string) error {
	a.l().Mth("DeleteUser").C(ctx)

	if err := a.container.Db.Instance.Model(&user{
		Id: id,
	}).Updates(map[string]interface{}{
		"deleted_at": time.Now(),
	}).Error; err != nil {
		return errors.ErrUserStorageUpdate(err, ctx, id)
	}
	// clear cache
	keys := []string{CacheKeyUserId + id}
	a.container.Cache.Instance.Del(keys...)

	return nil
}

func (a *userStorageImpl) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) {
	l := a.l().Mth("GetUserByEmail").C(ctx).Dbg()

	key := CacheKeyUserEmail + email
	if j, err := a.container.Cache.Instance.Get(key).Result(); err == nil {
		// found in cache
		l.Dbg("found in cache")
		dto := &user{}
		if err := json.Unmarshal([]byte(j), &dto); err != nil {
			return nil, errors.ErrUserStorageGetCacheByEmail(err, ctx, email)
		}
		return a.toUserDomain(dto), nil
	} else {
		if err == redis.Nil {
			// not found in cache
			dto := &user{Email: email}
			if res := a.container.Db.Instance.Limit(1).Where("deleted_at is null").Find(&dto, "email = ?", email); res.Error == nil {
				l.DbgF("db: found %d", res.RowsAffected)
				if res.RowsAffected == 0 {
					return nil, nil
				} else {
					// set cache async
					a.setUserCacheAsync(ctx, *dto, key)
					return a.toUserDomain(dto), nil
				}
			} else {
				return nil, errors.ErrUserStorageGetDbByEmail(res.Error, ctx, email)
			}

		} else {
			return nil, errors.ErrUserStorageGetCacheByEmail(err, ctx, email)
		}
	}
}

func (a *userStorageImpl) GetUserByFireUUID(ctx context.Context, idToken string) (*domain.User, error) {
	l := a.l().Mth("GetUserByFirebaseUUID").C(ctx).Dbg()

	key := CacheKeyUserToken + idToken
	if j, err := a.container.Cache.Instance.Get(key).Result(); err == nil {
		// found in cache
		l.Dbg("found in cache")
		dto := &user{}
		if err := json.Unmarshal([]byte(j), &dto); err != nil {
			return nil, errors.ErrUserStorageGetCacheByToken(err, ctx, idToken)
		}
		return a.toUserDomain(dto), nil
	} else {
		if err == redis.Nil {
			// not found in cache
			dto := &user{FirebaseUUID: idToken}
			if res := a.container.Db.Instance.Limit(1).Where("deleted_at is null").Find(&dto, "firebase_uuid = ?", idToken); res.Error == nil {
				l.DbgF("db: found %d", res.RowsAffected)
				if res.RowsAffected == 0 {
					return nil, nil
				} else {
					// set cache async
					a.setUserCacheAsync(ctx, *dto, key)
					return a.toUserDomain(dto), nil
				}
			} else {
				return nil, errors.ErrUserStorageGetDbByToken(res.Error, ctx, idToken)
			}

		} else {
			return nil, errors.ErrUserStorageGetCacheByToken(err, ctx, idToken)
		}
	}
}

func (a *userStorageImpl) GetUserByKundelikId(ctx context.Context, idToken string) (*domain.User, error) {
	l := a.l().Mth("GetUserByKundelikId").C(ctx).Dbg()

	key := CacheKeyUserToken + idToken
	if j, err := a.container.Cache.Instance.Get(key).Result(); err == nil {
		// found in cache
		l.Dbg("found in cache")
		dto := &user{}
		if err := json.Unmarshal([]byte(j), &dto); err != nil {
			return nil, errors.ErrUserStorageGetCacheByToken(err, ctx, idToken)
		}
		return a.toUserDomain(dto), nil
	} else {
		if err == redis.Nil {
			// not found in cache
			dto := &user{KundelikId: idToken}
			if res := a.container.Db.Instance.Limit(1).Where("deleted_at is null").Find(&dto, "kundelik_id = ?", idToken); res.Error == nil {
				l.DbgF("db: found %d", res.RowsAffected)
				if res.RowsAffected == 0 {
					return nil, nil
				} else {
					// set cache async
					a.setUserCacheAsync(ctx, *dto, key)
					return a.toUserDomain(dto), nil
				}
			} else {
				return nil, errors.ErrUserStorageGetDbByToken(res.Error, ctx, idToken)
			}

		} else {
			return nil, errors.ErrUserStorageGetCacheByToken(err, ctx, idToken)
		}
	}
}
