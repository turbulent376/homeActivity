// this file is generated by servgen util based on a template at 2021-06-26 10:37:24 +0300 MSK
package activity

import (
	"context"
	"github.com/turbulent376/kit/service"
	"github.com/turbulent376/homeactivity/activity/internal/config"
	"github.com/turbulent376/homeactivity/activity/internal/domain"
	"github.com/turbulent376/homeactivity/activity/internal/domain/impl"
	"github.com/turbulent376/homeactivity/activity/internal/grpc"
	"github.com/turbulent376/homeactivity/activity/internal/logger"
	"github.com/turbulent376/homeactivity/activity/internal/meta"
	"github.com/turbulent376/homeactivity/activity/internal/repository/storage"
)

// serviceImpl implements a service bootstrapping
// all dependencies between layers must be specified here
type serviceImpl struct {
	service.Cluster
	cfg              *config.Config
	activityService domain.ActivityService
	grpc             *grpc.Server
	storageAdapterA  storage.Adapter
	storageAdapterT  storage.Adapter
}

// New creates a new instance of the service
func New() service.Service {

	s := &serviceImpl{
		Cluster: service.NewCluster(logger.LF(), meta.Meta),
	}

	s.storageAdapterA = storage.NewAdapter()
	s.storageAdapterT = storage.NewAdapter()

	s.activityService = impl.NewActivityService(s.storageAdapterA, s.storageAdapterT)

	s.grpc = grpc.New(s.activityService)

	return s
}

func (s *serviceImpl) GetCode() string {
	return meta.Meta.ServiceCode()
}

// Init does all initializations
func (s *serviceImpl) Init(ctx context.Context) error {

	// load config
	var err error
	s.cfg, err = config.Load()
	if err != nil {
		return err
	}

	// set log config
	logger.Logger.Init(s.cfg.Log)

	// init cluster
	if err := s.Cluster.Init(s.cfg.Cluster, s.cfg.Nats.Host, s.cfg.Nats.Port, s.onClusterLeaderChanged(ctx)); err != nil {
		return err
	}

	// init storage
	if err := s.storageAdapterT.Init(s.cfg.Storages); err != nil {
		return err
	}
	if err := s.storageAdapterA.Init(s.cfg.Storages); err != nil {
		return err
	}

	// init grpc server
	if err := s.grpc.Init(s.cfg.Grpc); err != nil {
		return err
	}

	return nil

}

func (s *serviceImpl) onClusterLeaderChanged(ctx context.Context) service.OnLeaderChangedEvent {

	// if the current node is getting a leader, run daemons
	return func(l bool) {
		if l {
			// do something if the node is turned into a leader
			logger.L().C(ctx).Cmp("cluster").Mth("on-leader-change").Dbg("leader")
		}
	}

}

func (s *serviceImpl) Start(ctx context.Context) error {

	// start cluster
	if err := s.Cluster.Start(); err != nil {
		return err
	}

	// serve gRPC connection
	s.grpc.ListenAsync()

	return nil
}

func (s *serviceImpl) Close(ctx context.Context) {
	s.Cluster.Close()
	s.storageAdapterA.Close()
	s.storageAdapterT.Close()
	s.grpc.Close()
}
